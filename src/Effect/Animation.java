package Effect;import java.awt.*;import java.awt.geom.AffineTransform;import java.awt.image.AffineTransformOp;import java.awt.image.BufferedImage;import java.util.ArrayList;/** * class làm animation cho các đối tượng */public class Animation {    private String name;    private boolean isRepeated;         // nếu false thi animation không lặp lại    private ArrayList<FrameImage> frameImages;                  // chứa các frame của 1 chuyển động    private int currentFrame;                                   // frame hiện tại đang vẽ trền màn hình    private ArrayList<Boolean> ignoreFrame;                     // loại động tác khởi đầu    private ArrayList<Double> delayFrame;                       // chứa các tham số thời gian delay từ frame này sang frame khác    private long beginTime;    private boolean drawRectFrame;                              // vẽ cái vùng bao quanh hình để dễ thấy hình khi code thôi    public Animation(){        delayFrame = new ArrayList<Double>();        beginTime = 0;        currentFrame = 0;                                       // frame dang hien = 0;        ignoreFrame = new ArrayList<>();        frameImages = new ArrayList<>();        drawRectFrame = false;                              // mawcj dinh laf false khi nào cần vẽ mới để true        isRepeated = true;    }    public Animation(Animation animation){        /**         * muốn copy ra đối tượng mới         * các kiểu dữ liệu nguyên thủy không dùng địa chị bộ nhớ nên k bị chuyền tham chiếu giống như các object kia         * nên dùng gán được         */        beginTime = animation.beginTime;        currentFrame = animation.currentFrame;        drawRectFrame = animation.drawRectFrame;        isRepeated = animation.isRepeated;        delayFrame = new ArrayList<>();        for(Double d: animation.delayFrame){            delayFrame.add(d);        }        ignoreFrame = new ArrayList<>();        for (boolean b : animation.ignoreFrame){            ignoreFrame.add(b);        }        frameImages = new ArrayList<>();        for(FrameImage f : animation.frameImages){            frameImages.add(f);        }    }    /**     * các phương thuc get set     * @return     */    public String getName() {        return name;    }    public void setName(String name) {        this.name = name;    }    public boolean getRepeated() {        return isRepeated;    }    public void setRepeated(boolean repeated) {        isRepeated = repeated;    }    public ArrayList<FrameImage> getFrameImages() {        return frameImages;    }    public void setFrameImages(ArrayList<FrameImage> frameImages) {        this.frameImages = frameImages;    }    public int getCurrentFrame() {        return currentFrame;    }    public void setCurrentFrame(int currentFrame) {        if(currentFrame>0 && currentFrame < frameImages.size()) this.currentFrame = currentFrame;        else this.currentFrame = 0;    }    public ArrayList<Boolean> getIgnoreFrame() {        return ignoreFrame;    }    public void setIgnoreFrame(ArrayList<Boolean> ignoreFrame) {        this.ignoreFrame = ignoreFrame;    }    public ArrayList<Double> getDelayFrame() {        return delayFrame;    }    public void setDelayFrame(ArrayList<Double> delayFrame) {        this.delayFrame = delayFrame;    }    public long getBeginTime() {        return beginTime;    }    public void setBeginTime(long beginTime) {        this.beginTime = beginTime;    }    public boolean getDrawRectFrame() {        return drawRectFrame;    }    public void setDrawRectFrame(boolean drawRectFrame) {        this.drawRectFrame = drawRectFrame;    }    /**     * kiem tra frame này có phải là frame bị bỏ không     */    public boolean isIgnoreFrame(int id){        return ignoreFrame.get(id);    }    /**     * set frame bi bỉ qua     * @param id     */    public void setIgnoreFrame( int id){        if(id >=0 && id < ignoreFrame.size()) ignoreFrame.set(id, true);    }    /**     * mở frame bị bỏ     */    public void unIgnoreFrame( int id){        if(id >=0 && id < ignoreFrame.size()) ignoreFrame.set(id, false);    }    /** phuong thucwcs reset để set chuyển động về chuyển động khác, ví dụ đang chạy thì ngừng lại     * thì cái frame tiếp theo phải là frame của đứng chứ không phải frame chạy tiếp theo     */    public void reset(){        currentFrame = 0;        beginTime = 0;        for(int i=0; i< ignoreFrame.size(); i++) ignoreFrame.set(i,false);          // khong con frame nào bị bỏ nữa    }    /**     * them frame vao list     * @param frameImage     * @param timeToNextFrame     */    public void add(FrameImage frameImage, double timeToNextFrame){        ignoreFrame.add(false);        frameImages.add(frameImage);        delayFrame.add(new Double(timeToNextFrame));    }    /**     * get image     * @return     */    public BufferedImage getCurrentImage(){        return frameImages.get(currentFrame).getImage();    }    /**     * hàm update các khung hình frame, delta là thời gian hệ thống     * để update đều và ổn định với thời gian delay giữa các frame     * @param deltaTime     */    public void Update(long deltaTime){        if(beginTime == 0) beginTime = deltaTime;        else{            if(deltaTime - beginTime > delayFrame.get(currentFrame)){                nextFrame();                beginTime = deltaTime;            }        }    }    /**     * ham chuyển frame     */    public void nextFrame(){        if(currentFrame >= frameImages.size() - 1){         // nếu frame hiện tại là frame cuối            if(isRepeated) currentFrame = 0;                // nếu lặp tiếp thì current = 0 để lặp        }        else currentFrame++;                                    // không thì cộng lên        if(ignoreFrame.get(currentFrame)) nextFrame();          // nếu frame bị bỏ qua thì next (dẹ quy)    }    /**     * phương thức isLastFrame     * kiểm tra xem đã chạy xong animation chưa để chuyển trạng thái nhân vật     */    public boolean isLastFrame(){        if(currentFrame == frameImages.size() - 1)            return true;        else  return false;    }    /**     * ham vẽ frame     * @param x     * @param y     * @param g2     */    public void draw(int x, int y, Graphics2D g2){        BufferedImage image = getCurrentImage();            // vẽ frame hiện tại        g2.drawImage(image, x, y , null );        if(drawRectFrame){          // nếu viền bằng true            g2.drawRect(x , y, image.getWidth(), image.getHeight());        }       /* g2.drawImage(image, x - image.getWidth()/2, y - image.getHeight()/2, null );        if(drawRectFrame){          // nếu viền bằng true            g2.drawRect(x - image.getWidth()/2, x - image.getWidth()/2, image.getWidth(), image.getHeight());        }*/    }    public void flipAllImage(){        for (int i = 0; i < frameImages.size(); i++) {            BufferedImage image = frameImages.get(i).getImage();            AffineTransform tx = AffineTransform.getScaleInstance(-1,1);            tx.translate(-image.getWidth(), 0);            AffineTransformOp op = new AffineTransformOp(tx, AffineTransformOp.TYPE_BILINEAR);            image = op.filter(image, null);            frameImages.get(i).setImage(image);        }    }}