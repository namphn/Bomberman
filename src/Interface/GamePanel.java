package Interface;import Object.Scores;import Map.BuffItem;import Object.Bom;import Object.BomberMan;import Effect.Animation;import Effect.CacheDataLoader;import Effect.FrameImage;import Map.Manager;import javax.imageio.ImageIO;import javax.swing.*;import java.awt.*;import java.awt.event.KeyEvent;import java.awt.event.KeyListener;import java.awt.image.BufferedImage;import java.io.File;import java.io.IOException;public class GamePanel extends JPanel implements  Runnable, KeyListener {    private Thread thread;    private InputManager inputManager;    private boolean isRunning;    private BufferedImage image;                                                // đối tượng để truyền hình ảnh    private BufferedImage win;    private BufferedImage bufImage;    private BuffItem buff = new BuffItem();    private Manager mMagager = new Manager(1,buff);    private Scores scores;    BomberMan bomberMan = new BomberMan(300,500,42,60,0,0,mMagager);    public  GamePanel()  {        inputManager = new InputManager(this, mMagager);        try {            image = ImageIO.read(new File("src/Images/background_Play3.png"));            win = ImageIO.read(new File("src/Images/win.png"));        } catch (IOException e) {            e.printStackTrace();        }        bufImage = new BufferedImage(GameScreen.SCREEN_WIDTH,GameScreen.SCREEN_HEIGHT,BufferedImage.TYPE_INT_ARGB);        scores = new Scores(mMagager);    }    public boolean iswin(){        if(mMagager.getArrMonster().size()==0) return true;        else return false;    }    /**     * implement bộ lắng nghe sự kiện bàn phímk     * Jpanel nhu một khung chứa con bên trong Frame     * dùng sleep để giới hạn frame trong 1 giây,     * cài đặt giao diện cửa Runable để run game     */    /**     * khi add panel vào Frame, paint được tự động gọi, khi gọi thì nó sẽ tự động     * gọi đến super() nên override lại thì sẽ làm cái khác mà không cần phải viết     *lại phương thức cũ để nó hiện panel nữa     * @param g     */    @Override    public void paint(Graphics g){        Graphics2D g2d = (Graphics2D) g;        g.drawImage(image,0,0,null);        mMagager.drawAllItem(g2d);        mMagager.drawAllBox(g2d);        //else {            bomberMan.draw(g2d);            mMagager.drawAllMonster(g2d);        //}        g2d.setColor(Color.WHITE);        g2d.setFont(new Font("Arial", Font.BOLD, 45));        g2d.drawString(scores.getScores(),784,204);        //g.drawImage(bufImage,0,0,null);        if(bomberMan.isDied()){            bomberMan.drawOverGame(g2d);        }        if(this.iswin()) {            g2d.drawImage(win,GameScreen.SCREEN_WIDTH / 2-90 - win.getWidth() / 2,                    GameScreen.SCREEN_HEIGHT / 2 - win.getHeight() / 2, null);        }    }    /**     * run threads     * khi gọi đến phương thức thread.start() thì nó sẽ gọi và chạy Interface.GamePanel này và chạy     * hàm run()     */    public void startGame(){        if(thread == null) {            thread = new Thread(this);            isRunning = true;            thread.start();        }    }    /**     * hàm render     */    public void UpdateGame(long time){        bomberMan.update(time);        mMagager.enemyImpaction();        scores.update();    }    public void RenderGame(){        bomberMan.eatItem();        bomberMan.Impaction();    }    /**     * run() bawts bắt đầu chạy game bởi vòng while gồm 2 tiến trình là     * update và render     */    @Override    public void run() {        /**         * khi chạy game thì thời gian load 2 phương thức sẽ không ổn đinh, quá nhanh nên         * cần phải giới hạn lại, số frame trên 1 giây, để khi chạy game ta có tốc độ ổn đinh         * giới hạn thời gian chạy update và render game bằng cách sử dụng sleep         * giới hạn 1 fram trong 1 thời gian T         *  thời gian bắt đầu thực thi  2 hàm begin - thời gian thực hiện sau last         *  thì => thời gian cần sleep là T - (last - begin)         */        long FPS = 100;  // 80 frame/s        // đang sử dụng nano second        long beginTime;        long sleepTime;        /**         * 80 frame / 1s         * 80 vongf wgle trong 1 s bấm phím         *         * 150 frame         * 150 vòng trong 1s         * bấm phím 1s         *         */        long period = 1000000000 / FPS;  // cái này tương đương 1s/80 FRAME 1s = 1000000000 nanos        beginTime = System.nanoTime();              // lấy thời gian bắt đầu        while (isRunning = true){            UpdateGame(System.nanoTime());               //speed + 5            RenderGame();            repaint();            long deltaTime = System.nanoTime() - beginTime;             // thời gian thực thi update và render            sleepTime = period - deltaTime;                             // thời gian ngủ            if (bomberMan.isDied() == true){                break;            }            if(this.iswin()) break;            try{                if(sleepTime > 0) {                    Thread.sleep(sleepTime/1000000);         // ngu sleepTime/1000000 milis                }                else Thread.sleep(period/2000000);            }            catch (Exception e){            }            beginTime = System.nanoTime();                  // lấy lại begin time dể bắt đầu chu kỳ mới        }    }    public Scores getScores() {        return scores;    }    @Override    public void keyTyped(KeyEvent e) {    }    /**     * nhận sự kiện khi ấn  bàn phím     * @param e     */    @Override    public void keyPressed(KeyEvent e) {        inputManager.processKeyPreesed(e.getKeyCode());    }    /**     * nhận sự kiện khi nhả bàn phím     * @param e     */    @Override    public void keyReleased(KeyEvent e) {        inputManager.processKeyReleased(e.getKeyCode());    }}